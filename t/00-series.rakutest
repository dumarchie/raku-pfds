use v6.d;
use Test;

use lib 'lib';
use PFDS;

subtest 'series', {
    subtest 'empty series', {
        $_ := series;
        isa-ok $_, PFDS::Series, 'series() returns a PFDS::Series';
        cmp-ok .Bool, '=:=', False, '.Bool returns False';
        cmp-ok .head, '=:=', Nil, '.head returns Nil';
        cmp-ok .list, 'eqv', (), '.list returns no values';
        cmp-ok .skip, '=:=', $_, '.skip returns the invocant';
    }

    subtest 'series($item)', {
        my \value = Mu.new;
        my $item  = value;
        $_ := series($item);
        isa-ok $_, PFDS::Series::Node,
          'series($item) returns a PFDS::Series::Node';

        cmp-ok .Bool, '=:=', True, '.Bool returns True';

        $item = Mu.new; # to check that the .head is bound to the bare value
        cmp-ok .head, '=:=', value,
          '.head returns the value of $item when series($item) was called';

        cmp-ok .skip, 'eqv', series(), '.skip returns the empty series';
    }

    subtest 'series(1, 2)', {
        $_ := series(1, 2);
        isa-ok $_, PFDS::Series::Node,
          'series(1, 2) returns a PFDS::Series::Node';

        cmp-ok .head, '=:=', 1, '.head returns the value 1';
        cmp-ok .list, 'eqv', (1, 2), '.list returns values 1, 2';
        cmp-ok .skip, 'eqv', series(2), '.skip returns series(2)';
    }

    # Check that a Slip slips
    cmp-ok series(Empty), 'eqv', series(),
      'series(Empty) returns the empty series';
}

# A Producer keeps track of how many values have been produced
# so we can check that streams are as lazy as possible
my class Producer is Range  {
    has int $.produced;

    method produce(int \pos) {
        my \value := self.min + pos;
        return Nil if value > self.max;

        $!produced = pos + 1;
        $(value);
    }

    method iterator() {
        my class :: does Iterator {
            has $.producer;
            has int $.pos;

            method pull-one() is raw {
                $!producer.produce($!pos++) // IterationEnd;
            }
        }.new(producer => self);
    }
}

subtest 'stream', {
    my \values = Producer.new(0, 3);
    $_ := stream(values);
    isa-ok $_, PFDS::Stream, "stream(values) returns a PFDS::Stream";
    is values.produced, 0, 'no values were evaluated';

    cmp-ok .Bool, '=:=', True, '.Bool returns True';
    cmp-ok .head, '=:=', 0, '.head returns the first value';
    subtest '.skip', {
        isa-ok $_, PFDS::Stream, "the result is a PFDS::Stream";
        is values.produced, 1, 'only the first of the values was evaluated';
        cmp-ok $_, 'eqv', stream(1..3),
          'the second stream evaluates the rest of the values on demand';
    } given .skip;
}

subtest 'infix ++', {
    $_ := series(1) ++ stream(2, 3);
    isa-ok $_, PFDS::Stream,
      "series(1) ++ stream(2, 3) returns a PFDS::Stream";

    cmp-ok .Bool, '=:=', True, '.Bool returns True';
    cmp-ok .head, '=:=', 1, '.head returns 1';
    cmp-ok .list, 'eqv', (1, 2, 3), '.list returns (1, 2, 3)';
    cmp-ok .skip, 'eqv', stream(2, 3), '.skip returns stream(2, 3)';
}


subtest 'head(n, values)', {
    my \values = series(1, 2, 3);
    cmp-ok head(0.9, values), 'eqv', series,
      'head(n, values) returns the empty series if n < 1';

    cmp-ok head(1, values), 'eqv', stream(1),
      'head(1, values) returns a stream with the first value of the invocant';

    cmp-ok head(4, values), 'eqv', stream(1..3),
      'head(n, values) returns a stream with the first n values';
}

subtest 'insert($item, values)', {
    my $item = my \value = Mu.new;
    my \values = stream();
    $_ := insert($item, values);
    isa-ok $_, PFDS::Series::Node,
      'insert($item, values) returns a PFDS::Series::Node';

    $item = 42;
    cmp-ok .head, '=:=', value,
      '.head returns the value of $item at insert time';

    cmp-ok .skip, '=:=', values, '.skip returns the original values';

    $_ := insert($item, values.WHAT);
    cmp-ok .skip, '=:=', series,
      '.skip returns the empty series if the second argument was not defined';
}

{
    my \values = series(1, 2, 3);
    cmp-ok reverse(values), 'eqv', series(3, 2, 1), 'reverse(values)';
}

subtest 'skip(n, values)', {
    my \values = series(1) ++ stream(2..3);
    cmp-ok skip(0.9, values), '=:=', values,
      'skip(n, values) returns the invocant if n < 1';

    cmp-ok skip(1, values), 'eqv', stream(2..3),
      'skip(1, values) returns the series following the first value';

    cmp-ok skip(3.9, values), 'eqv', stream(),
      'skip(n, values) returns an empty stream if n.Int == values.elems';

    cmp-ok skip(4, values), 'eqv', series(),
      'skip(n, values) returns the empty series if n.Int > values.elems';
}

done-testing;
